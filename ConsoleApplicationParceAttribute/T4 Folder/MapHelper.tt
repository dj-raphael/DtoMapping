<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="C:\Program Files (x86)\Common Files\microsoft shared\MSEnv\PublicAssemblies\envdte.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection"#>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Text.RegularExpressions" #>

<# 
    // create an instance of the MapHelperClass class so 
    // that it is accessible from everywhere within the template
    this.MapHelper = new MapHelperClass(this.Host);
#><#+
/// <summary>
/// Object that provides functionality for automating Visual Studio.
/// </summary>
public MapHelperClass MapHelper;

/// <summary>
/// This class provides functionality for automating Visual Studio.
/// </summary>
public class MapHelperClass 
{
        
    /// <summary>
    /// Creates a new instance of this class
    /// </summary>
    public MapHelperClass(object host)
    {
        // store a reference to the template host
        // we will need this frequently
        this.Host = host as ITextTemplatingEngineHost;
    }
    
    private EnvDTE.DTE _DTE = null;
    /// <summary>
    /// Returns a reference to the primary management object of Visual Studio
    /// <summary>
    public EnvDTE.DTE DTE
    {
        get
        {
            if (_DTE == null)
            {
                var hostServiceProvider = this.Host as IServiceProvider;
                if (hostServiceProvider != null)
                    _DTE = hostServiceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
            }
            return _DTE;
        }
    }
    
    /// <summary>
    /// Stores a reference to the Host of the t4 template
    /// </summary>
    public ITextTemplatingEngineHost Host { get; private set; }

    public Dictionary<string,string[]> SystemNullableTypes = new Dictionary<string,string[]>
    {
        {"int", new string[]{"int?", "System.Int32?", "System.Nullable<int>", "System.Nullable<System.Int32>"}},
        {"System.Int32",new string[]{"int?", "System.Int32?", "System.Nullable<int>", "System.Nullable<System.Int32>"}},

        {"short", new string[]{"short?", "System.Int16?", "System.Nullable<short>", "System.Nullable<System.Int16>"}},
        {"System.Int16", new string[]{"short?", "System.Int16?", "System.Nullable<short>", "System.Nullable<System.Int16>"}},

        {"long", new string[]{"long?", "System.Int64?", "System.Nullable<long>", "System.Nullable<System.Int64>"}},
        {"System.Int64", new string[]{"long?", "System.Int64?", "System.Nullable<long>", "System.Nullable<System.Int64>"}},

        {"decimal", new string[]{"decimal?", "System.Decimal?", "System.Nullable<decimal>", "System.Nullable<System.Decimal>"}},
        {"System.Decimal", new string[]{"decimal?", "System.Decimal?", "System.Nullable<decimal>", "System.Nullable<System.Decimal>"}},
        
        {"float", new string[]{"float?", "System.Single?", "System.Nullable<float>", "System.Nullable<System.Single>"}},
        {"System.Single", new string[]{"float?", "System.Single?", "System.Nullable<float>", "System.Nullable<System.Single>"}},
        
        {"double", new string[]{"double?", "System.Double?", "System.Nullable<double>", "System.Nullable<System.Double>"}},
        {"System.Double", new string[]{"double?", "System.Double?", "System.Nullable<double>", "System.Nullable<System.Double>"}},

        {"bool", new string[]{"bool?", "System.Boolean?", "System.Nullable<bool>", "System.Nullable<System.Boolean>"}},
        {"System.Boolean", new string[]{"bool?", "System.Boolean?", "System.Nullable<bool>", "System.Nullable<System.Boolean>"}},

        {"byte", new string[]{"byte?", "System.Byte?", "System.Nullable<byte>", "System.Nullable<System.Byte>"}},
        {"System.Byte", new string[]{"byte?", "System.Byte?", "System.Nullable<byte>", "System.Nullable<System.Byte>"}},

        {"Guid", new string[]{"Guid?", "System.Guid?", "System.Nullable<Guid>", "System.Nullable<System.Guid>"}},
        {"System.Guid", new string[]{"Guid?", "System.Guid?", "System.Nullable<Guid>", "System.Nullable<System.Guid>"}},

        {"char", new string[]{"char?", "System.Char?", "System.Nullable<char>", "System.Nullable<System.Char>"}},
        {"System.Char", new string[]{"char?", "System.Char?", "System.Nullable<char>", "System.Nullable<System.Char>"}},

        {"DateTime", new string[]{"DateTime?", "System.DateTime?", "System.Nullable<DateTime>", "System.Nullable<System.DateTime>"}},
        {"System.DateTime", new string[]{"DateTime?", "System.DateTime?", "System.Nullable<DateTime>", "System.Nullable<System.DateTime>"}},

        {"sbyte", new string[]{"sbyte?", "System.SByte?", "System.Nullable<sbyte>", "System.Nullable<System.SByte>"}},
        {"System.SByte", new string[]{"sbyte?", "System.SByte?", "System.Nullable<sbyte>", "System.Nullable<System.SByte>"}},

        {"uint", new string[]{"uint?", "System.UInt32?", "System.Nullable<uint>", "System.Nullable<System.UInt32>"}},
        {"System.UInt32", new string[]{"uint?", "System.UInt32?", "System.Nullable<uint>", "System.Nullable<System.UInt32>"}},

        {"ulong", new string[]{"ulong?", "System.UInt64?", "System.Nullable<ulong>", "System.Nullable<System.UInt64>"}},
        {"System.UInt64", new string[]{"ulong?", "System.UInt64?", "System.Nullable<ulong>", "System.Nullable<System.UInt64>"}},

        {"ushort", new string[]{"ushort?", "System.UInt16?", "System.Nullable<ushort>", "System.Nullable<System.UInt16>"}},
        {"System.UInt16", new string[]{"ushort?", "System.UInt16?", "System.Nullable<ushort>", "System.Nullable<System.UInt16>"}},
    };

    public bool IsInNullableDictionary(string systemtype, string nullableType)
    {
        var nullableCollectionValue =  SystemNullableTypes.FirstOrDefault(x => x.Key.ToString().Trim() == systemtype).Value;
		
        if(nullableCollectionValue != null)
        {
			var nullableCollection  = nullableCollectionValue.ToList();
            if(nullableCollection.FirstOrDefault(x => x == nullableType) != null)
                return true;
        }

        return false;
    }

    public string GetMapName(CodeElement element)
    {
        var value = element.Name;
        const string nameAttribute = "Map";
        const string nameProperty = "Name";

        CodeElements attributes = null;

        var codeClass = element as CodeClass;
        if (codeClass != null)
        {
                attributes = codeClass.Attributes;
        }

        var codeProperty = element as CodeProperty;
        if (codeProperty != null)
        {
            attributes = codeProperty.Attributes;
        }

        foreach (CodeAttribute ca in attributes)
        {
            if (ca.Name.Contains(nameAttribute) && ca.Value.Contains(nameProperty))
            {
                value = ca.Value.Remove(0, ca.Value.IndexOf(nameProperty));
                value = value.Replace(" ", "");

                if (value.Contains(",")) 
                {
                    value = value.Remove(value.IndexOf(","));
                }

                value = value.Remove(0, nameProperty.Length + 1);
                value = value.Replace("\"", "").ToLower();

                if (value.EndsWith("dto") && codeClass != null)
                {
                    value = value.Replace("dto", "");
                }
            }
        }
        
        value = value.ToLower();

        if(value.EndsWith("dto") && codeClass != null)
        {
            value = value.Replace("dto", "");
        }
            
        return value;
    }

    public bool CompareTwoPropertyType(CodeProperty DOCodeProperty, CodeProperty DtoCodeProperty, List<MapDtoAndDo> listOfSimilarClasses)
    {
        var DOType = DOCodeProperty.Type.AsString;
        var DtoType = DtoCodeProperty.Type.AsString;

        if (DOType.Contains("IEnumerable") && DtoType.Contains("IEnumerable"))
        {
            DOType = DOType.Remove(0, DOType.IndexOf("<") + 1);
            DOType = DOType.Replace(">", "");

            DtoType = DtoType.Remove(0, DtoType.IndexOf("<") + 1);
            DtoType = DtoType.Replace(">", "");

            if (listOfSimilarClasses.FirstOrDefault(x => x.DOClass.FullName == DOType) == listOfSimilarClasses.FirstOrDefault(x => x.DtoClass.FullName == DtoType) )
            {
                return true;
            }
        }

        var mapDtoAndDo = listOfSimilarClasses.FirstOrDefault(x => x.DOClass.FullName == DOType);
        if (mapDtoAndDo != null && mapDtoAndDo.DtoClass.FullName == DtoType)
        {
            return true;
        }

        if (DOType == DtoType)
        {
            return true;
        }


        return false;
    }

    public KindOfProperty GetKindOfMapProperty(CodeProperty codeProperty, List<MapDtoAndDo> listOfSimilarClasses)
    {
        var type = codeProperty.Type.AsString;


        if (type.Contains("IEnumerable"))
        {
            type = type.Remove(0, type.IndexOf("<") + 1);
            type = type.Replace(">", "");

            if (listOfSimilarClasses.Any(x => x.DOClass.FullName == type)) 
            {
               return KindOfProperty.CollectionAttributeClasses;
            }
        }

        if (listOfSimilarClasses.Any(x => x.DOClass.FullName == type)) 
        {
            return KindOfProperty.AttributeClass;
        }

        return KindOfProperty.None;
    }
}

    public class MapDtoAndDo
    {
        public CodeClass DOClass { get; set; }
        public CodeClass DtoClass { get; set; }
        public IEnumerable<MapPropertiesDtoAndDo> MapPropertiesDtoAndDo { get; set; }
    }

    public class MapPropertiesDtoAndDo
    {
        public CodeProperty DOPropertyName { get; set; }
        public CodeProperty DTOPropertyName { get; set; }
        public CodeTypeRef DOPropertyType { get; set; }
        public CodeTypeRef DtoropertyType { get; set; }
        public string ToDtoFunction { get; set; }
        public string FromDtoFunction { get; set; }
        public KindOfProperty KindOMapfProperty { get; set; }
    }

    public enum KindOfProperty
    {
        AttributeClass = 1,
        CollectionAttributeClasses = 2,
        FunctionAttribute = 3,
        None = 9
    }

#>